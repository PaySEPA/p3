/*
 * Copyright (c) 2012 Digital Bazaar, Inc. All rights reserved.
 */
var async = require('async');
var payswarm = {
  config: require('payswarm.config'),
  db: require('payswarm.database'),
  identity: require('payswarm.identity'),
  logger: require('payswarm.logger'),
  permission: require('payswarm.permission'),
  profile: require('payswarm.profile'),
  security: require('payswarm.security')
};

// constants
var MODULE_TYPE = 'payswarm.financial';
var MODULE_IRI = 'https://payswarm.com/modules/financial';

// module permissions
var PERMISSIONS = {
  // account permissions
  ACCOUNT_ADMIN: MODULE_IRI + '#account_admin',
  ACCOUNT_ACCESS: MODULE_IRI + '#account_access',
  ACCOUNT_CREATE: MODULE_IRI + '#account_create',
  ACCOUNT_EDIT: MODULE_IRI + '#account_edit',
  ACCOUNT_REMOVE: MODULE_IRI + '#account_remove',
  // budget permissions
  BUDGET_ADMIN: MODULE_IRI + '#budget_admin',
  BUDGET_ACCESS: MODULE_IRI + '#budget_access',
  BUDGET_CREATE: MODULE_IRI + '#budget_create',
  BUDGET_EDIT: MODULE_IRI + '#budget_edit',
  BUDGET_REMOVE: MODULE_IRI + '#budget_remove',
  // payment token permissions
  PTOKEN_ADMIN: MODULE_IRI + '#payment_token_admin',
  PTOKEN_ACCESS: MODULE_IRI + '#payment_token_access',
  PTOKEN_CREATE: MODULE_IRI + '#payment_token_create',
  PTOKEN_EDIT: MODULE_IRI + '#payment_token_edit',
  PTOKEN_REMOVE: MODULE_IRI + '#payment_token_remove'
};

// module API
var api = {};
api.name = MODULE_TYPE + '.Financial';
module.exports = payswarm.tools.extend(
  api,
  require('payswarm.budget'),
  require('payswarm.paymentToken'),
  require('payswarm.contract'),
  require('payswarm.deposit'),
  require('payswarm.withdrawal')
);

/**
 * Initializes this module.
 *
 * @param app the application to initialize this module for.
 * @param callback(err) called once the operation completes.
 */
api.init = function(app, callback) {
  // do initialization work
  async.waterfall([
    function openCollections(callback) {
      // open all necessary collections
      payswarm.db.openCollections([
        'account', 'budget', 'paymentToken'], callback);
    },
    function setupCollections(callback) {
      // setup collections (create indexes, etc)
      payswarm.db.createIndexes([{
        collection: 'account',
        fields: {id: 1},
        options: {unique: true, background: true}
      }, {
        collection: 'budget',
        fields: {id: 1},
        options: {unique: true, background: true}
      }, {
        collection: 'paymentToken',
        fields: {id: 1},
        options: {unique: true, background: true}
      }], callback);
    },
    _registerPermissions,
    function createAccounts(callback) {
      // create accounts, ignoring duplicate errors
      async.forEachSeries(
        payswarm.config.financial.accounts,
        function(a, callback) {
          _createAccount(a, function(err) {
            if(err && !payswarm.db.isDuplicateError(err)) {
              err = null;
            }
            callback(err);
          });
        },
        callback);
    }
  ], callback);
};

/**
 * Creates a new Account ID based on the owner's Identity ID and the given
 * name.
 *
 * @param ownerId the ID of the Identity account owner.
 * @param name the name of the account (slug).
 *
 * @return the AccountId for the Account.
 */
api.createAccountId(ownerId, name) {
  return util.format('%s/accounts/%s', ownerId, encodeURIComponent(name));
};

/**
 * Creates a new Account.
 *
 * The Account must contain @id and an owner.
 *
 * @param actor the Profile performing the action.
 * @param account the Account to create.
 * @param callback(err) called once the operation completes.
 */
api.createAccount = function(actor, account, callback) {
  async.waterfall([
    function(callback) {
      api.checkActorPermission(
        actor, account,
        PERMISSIONS.ACCOUNT_ADMIN, PERMISSIONS.ACCOUNT_CREATE,
        _checkAccountOwner, callback);
    },
    function(callback) {
      _createAccount(account, callback);
    }
  ], callback);
};

/**
 * Retrieves all Accounts owned by a particular Identity.
 *
 * @param actor the Profile performing the action.
 * @param identityId the ID of the Identity to get the Accounts for.
 * @param callback(err, records) called once the operation completes.
 */
api.getIdentityAccounts = function(actor, identityId, callback) {
  async.waterfall([
    function(callback) {
      api.checkActorPermission(
        actor, PERMISSIONS.ACCOUNT_ADMIN, PERMISSIONS.ACCOUNT_ACCESS,
        callback);
    },
    function(callback) {
      payswarm.db.collections.account.find(
        {owner: payswarm.db.hash(identityId)},
        payswarm.db.readOptions).toArray(callback);
    }
  ], callback);
};

/**
 * Retrieves all Accounts matching the given query.
 *
 * @param actor the Profile performing the action.
 * @param query the query to use (defaults to {}).
 * @param callback(err, records) called once the operation completes.
 */
api.getAccounts = function(actor, query, callback) {
  query = query || {};
  async.waterfall([
    function(callback) {
      api.checkActorPermission(actor, PERMISSIONS.ACCOUNT_ADMIN, callback);
    },
    function(callback) {
      payswarm.db.collections.account.find(
        query, payswarm.db.readOptions).toArray(callback);
    }
  ], callback);
};

/**
 * Retrieves an Account.
 *
 * @param actor the Profile performing the action.
 * @param id the ID of the Account to retrieve.
 * @param callback(err, account, meta) called once the operation completes.
 */
api.getAccount = function(actor, id, callback) {
  async.waterfall([
    function(callback) {
      payswarm.db.collections.account.findOne(
        {id: payswarm.db.hash(id)},
        payswarm.db.readOptions, callback);
    },
    function(result, callback) {
      callback(null, result.account, result.meta);
    },
    function(callback, account, meta) {
      api.checkActorPermissionForObject(
        actor, account,
        PERMISSIONS.ACCOUNT_ADMIN, PERMISSIONS.ACCOUNT_ACCESS,
        _checkAccountOwner, function(err) {
          callback(err, account, meta);
        });
    },
  ], callback);
};

/**
 * Updates an existing Account.
 *
* @param actor the Profile performing the action.
* @param account the Account to update.
* @param callback(err) called once the operation completes.
*/
api.updateAccount = function(actor, account, callback) {
 async.waterfall([
   function(callback) {
     api.checkActorPermissionForObject(
       actor, account,
       PERMISSIONS.ACCOUNT_ADMIN, PERMISSIONS.ACCOUNT_EDIT,
       _checkAccountOwner, callback);
   },
   function(callback) {
     // remove restricted fields
     account = payswarm.tools.clone(account);
     delete account['ps:owner'];
     delete account['psa:status'];
     delete account['com:balance'];
     delete account['com:escrow'];
     delete account['com:currency'];
     payswarm.db.collections.account.update(
       {id: payswarm.db.hash(account['@id'])},
       {$set: payswarm.db.buildUpdate(account)},
       payswarm.db.writeOptions,
       callback);
   },
   function(n, callback) {
     if(n === 0) {
       callback(new payswarm.tools.PaySwarmError(
         'Could not update Account. Account not found.',
         MODULE_TYPE + '.AccountNotFound'));
     }
     else {
       callback();
     }
   }
 ], callback);
};

/**
 * Generates the next Transaction ID.
 *
 * @param callback(err, id) called once the operation completes.
 */
api.generateTransactionId = function(callback) {
  // FIXME: implement me
};

/**
 * Creates and populates a new Contract. The Asset acquirer will not be set
 * on the contract until it is signed.
 *
 * If a Listing ID is provided, the Listing will be retrieved, otherwise
 * a the full Listing must be provided. An asset and license may be provided,
 * otherwise they will be retrieved. Providing these options optimize away
 * retrievals.
 *
 * @param actor the profile performing the action.
 * @param options:
 *          listingId: the Listing ID (to look up Listing).
 *          listing: the full Listing (to use given Listing).
 *          listingHash: the Listing hash.
 *          asset: the Asset (optional, will be retrieved otherwise).
 *          license: the License (optional, will be retrieved otherwise).
 *          contract: the contract to populate (with reference ID if applies).
 * @param callback(err, contract) called once the operation completes.
 */
api.createContract = function(actor, options, callback) {
  // FIXME: implement me
};

/**
 * Attempts to add a Payee to a Contract. If the Payee is valid and the
 * Contract's Listing's Payee Rules permit the Payee to be added, it will
 * be. If not, an error will be raised.
 *
 * This must be called before finalizing the Contract.
 *
 * @param contract the Contract to add a Payee to.
 * @param payee the Payee to add.
 * @param options:
 *          maximizeRate: true to try to maximize the Payee's rate based on
 *            the given Payee Rules, false not to (default: false).
 *          ownerType: the owner type for the Payee destination account,
 *            (default: 'identity', other option: 'authority').
 * @param callback(err) called once the operation completes.
 */
api.addPayeeToContract = function(contract, payee, options, callback) {
  // FIXME: implement me
};

/**
 * Creates a new PayeeScheme ID based on the owner's Identity ID and the
 * given name (slug).
 *
 * @param ownerId the ID of the PayeeScheme owner.
 * @param name the name of the PayeeScheme (slug).
 *
 * @return the PayeeScheme ID.
 */
api.createPayeeSchemeId = function(ownerId, name) {
  return util.format('%s/payee-schemes/%s', ownerId, encodeURIComponent(name));
};

/**
 * Adds the Payees from a particular PayeeScheme to the given Contract.
 *
 * This must be called before finalizing the Contract.
 *
 * @param contract the Contract to add the Payees to.
 * @param psId the ID of the PayeeScheme to add Payees from.
 * @param options:
 *          maximizeRate: true to try to maximize the Payee's rate based on
 *            the given Payee Rules, false not to (default: false).
 *          ownerType: the owner type for the Payee destination account,
 *            (default: 'identity', other option: 'authority').
 * @param callback(err) called once the operation completes.
 */
api.addPayeeSchemeToContract(contract, psId, options, callback) {
  // FIXME: implement me
};

/**
 * Validates and finalizes a Contract. This method will not actually process
 * the Contract, it will just assign it a unique ID, set its Asset acquirer,
 * populate its list of Transfers, set a total, and check appropriate
 * information. To process the Contract, call processContract() after it has
 * been reviewed and found to be acceptable by the appropriate Asset
 * provider.
 *
 * The Contract will be cached and can be later retrieved using a call to
 * getCachedContract().
 *
 * After the call returns successfully, the Contract will be the
 * "Asset acquirer's version" and it should not be given to the Asset
 * provider because it will contain identity information.
 *
 * @param actor the profile performing the action.
 * @param contract the Contract to finalize.
 * @param options:
 *          assetAcquirer: the Asset acquirer to use.
 *          acquirerAccountId: the Asset acquirer's Account ID.
 * @param callback(err) called once the operation completes.
 */
api.finalizeContract = function(actor, contract, options, callback) {
  // FIXME: implement me
};

/**
 * Ensures that the Payee amounts in the given Contract meet the minimums
 * specified in the given PayeeScheme.
 *
 * This should be called after finalizing the Contract (which is when
 * Transfers will be generated). This method will be automatically called
 * if the "createFinalizedContract" API is used.
 *
 * @param contract the Contract to check.
 * @param psId the ID of the PayeeScheme to check.
 * @param callback(err) called once the operation completes.
 */
api.checkPayeeAmounts = function(contract, psId, callback) {
  // FIXME: implement me
};

/**
 * A helper-method that:
 *
 * 1. Creates a Contract.
 * 2. Adds the default PaySwarm Authority PayeeScheme to it.
 * 3. Finalizes the Contract.
 * 4. Checks the Payee amounts on the finalized Contract.
 *
 * @see createContract
 *
 * @param actor the Profile performing the action.
 * @param contract the contract to populate (with reference ID if applies).
 * @param options:
 *          listingId: the Listing ID (to look up Listing).
 *          listing: the full Listing (to use given Listing).
 *          listingHash: the Listing hash.
 *          asset: the Asset (optional, will be retrieved otherwise).
 *          license: the License (optional, will be retrieved otherwise).
 *          assetAcquirer: the Asset acquirer to use.
 *          acquirerAccountId: the Asset acquirer's Account ID.
 * @param callback(err, contract) called once the operation completes.
 */
api.createFinalizedContract = function(actor, contract, options, callback) {
  // FIXME: implement me
};

/**
 * Processes a signed Contract. License issuance, financial Transactions,
 * and any other business is handled. This method must only be called
 * after finalizeContract().
 *
 * The options include:
 *
 * A "duplicateQuery" that can be used prevent duplicate purchases
 * from occurring. The query is used to determine if the Contract would
 * result in a duplicate purchase and should therefore cause the Transaction
 * to abort. See hasContract for details on "duplicateQuery".
 *
 * @param actor the Profile performing the action.
 * @param contract the Contract to process.
 * @param options:
 *          duplicateQuery a query used to prevent duplicates.
 *          escrowType: the escrow type to use (EscrowNone or EscrowReceive).
 * @param callback(err) called once the operation completes.
 */
api.processContract = function(actor, contract, options, callback) {
  // FIXME: implement me
};

/**
 * Retrieves a Contract by its ID.
 *
 * @param actor the Profile performing the action.
 * @param id the ID of the Contract to retrieve.
 * @param callback(err, contract, meta) called once the operation completes.
 */
api.getContract = function(actor, id, callback) {
  // FIXME: implement me
};

/**
 * Retrieves a previously-cached Contract by its ID. When Contracts are
 * finalized, they are written to a temporary cache so that they can
 * be retrieved later for processing.
 *
 * @param actor the profile Performing the action.
 * @param id the ID of the Contract to retrieve.
 * @param callback(err, contract, meta) called once the operation completes.
 */
api.getCachedContract = function(actor, id, callback) {
  // FIXME: implement me
};

/**
 * Signs a contract.
 *
 * @param actor the Profile performing the action.
 * @param contract the Contract to sign.
 * @param callback(err) called once the operation completes.
 */
api.signContract = function(actor, contract, callback) {
  // FIXME: implement me
};

/**
 * Verifies a contract.
 *
 * @param contract the Contract to verify.
 * @param callback(err, verified) called once the operation completes.
 */
api.verifyContract = function(contract, callback) {
  // FIXME: implement me
};

/**
 * Checks to see if a Contract exists for the given query parameters.
 *
 * The query must contain:
 *
 * identityId - the ID of the Identity to look for.
 * identityKey - the hashed ID of the Identity (optional optimization).
 *
 * The query may contain either:
 *
 * assetId - the ID of the Asset to look for.
 * assetKey - the hashed ID of the Asset (optional optimization).
 * combos - an optional array of possible asset hash + license combinations:
 *   assetHash - optional hash of a more specific Asset.
 *   licenseId - an optional ID of the License to look for.
 *   licenseKey - the hashed ID of the License (optional optimization).
 *   licenseHash - optional hash of a more specific License.
 *
 * OR
 *
 * referenceId - an ID (opaque to payswarm) specified by the merchant. Each
 *   reference ID is unique to an Identity. This allows for purchases of the
 *   same Asset by the same Identity using different reference IDs.
 *
 * @param actor the Profile performing the action.
 * @param query the query to use.
 * @param callback(err, exists) called once the operation completes.
 */
api.hasContract = function(actor, query, callback) {
  // FIXME: implement me
};

/**
 * Validates and signs a financial Deposit. This method will not actually
 * process the Deposit, it will not be submitted to any external payment
 * gateway. To process the Deposit, call processDeposit() after it has been
 * reviewed and found to be acceptable by the owner of the source account.
 *
 * @param actor the Profile performing the action.
 * @param deposit the Deposit to sign.
 * @param callback(err, deposit) called once the operation completes.
 */
api.signDeposit = function(actor, deposit, callback) {
  // FIXME: implement me
};

/**
 * Processes a signed financial Deposit. This method must only be called
 * after signDeposit().
 *
 * @param actor the Profile performing the action.
 * @param deposit the Deposit to process.
 * @param options:
 *          escrowType: the escrow type to use (EscrowNone or EscrowReceive).
 * @param callback(err, deposit) called once the operation completes.
 */
api.processDeposit = function(actor, deposit, options, callback) {
  // FIXME: implement me
};

/**
 * Processes a financial Transaction containing a list of financial
 * Transfers. The transaction ID will be generated and assigned by this
 * method.
 *
 * @param actor the Profile performing the action.
 * @param transaction the Transaction to process.
 * @param options:
 *          escrowType: the escrow type to use (EscrowNone or EscrowReceive).
 * @param callback(err) called once the operation completes.
 */
api.processTransaction = function(actor, transaction, options, callback) {
  // FIXME: implement me
};

/**
 * Processes a financial Withdrawal. This method must be called before the
 * physical monetary transfer to the Withdrawal's external source.
 *
 * @param actor the profile performing the action.
 * @param withdrawal the Withdrawal to process.
 * @param options:
 *          escrowType: the escrow type to use (EscrowNone or EscrowReceive).
 * @param callback(err) called once the operation completes.
 */
api.processWithdrawal = function(actor, withdrawal, options, callback) {
  // FIXME: implement me
};

/**
 * Voids an unsettled Transaction.
 *
 * @param actor the profile performing the action.
 * @param transaction the Transaction (can be a Deposit, Withdrawal, etc.) to
 *          void.
 * @param callback(err) called once the operation completes.
 */
api.voidTransaction = function(actor, transaction, callback) {
  // FIXME: implement me
};

// FIXME: update docs for this ...
/**
 * Populates the transactions associated with the given query.
 *
 * The query *must* contain "start" and "num" limitations. The query can
 * contain identity, account, asset, and license filtering information. It
 * can also specify a start and end date.
 *
 * start - the starting transaction index, 0 for the first one.
 * num - the maximum number of transactions to return.
 * identityId - the ID of the identity.
 * source - the source account ID.
 * destination - the destination account ID.
 * referenceId - the vendor-specified reference ID.
 * assetHash - the hash of the asset.
 * licenseHash - the hash of the license.
 * date.start - the starting date.
 * date.end - the ending date.
 * purchases - true to return only Contracts for a particular identityId,
 *    account query parameters will be ignored (default: false).
 * details - true to return the full details of the transaction (eg: full
 *    Contract details), (default: true).
 *
 * Advanced options:
 * assetIdxKey - the index key for the asset.
 * identityIdxKey - the index key for the identity.
 * accountSecIdxKey - the index key for the source account.
 * accountDstIdxKey - the index key for the destination account.
 *
 * @param actor the profile performing the action.
 * @param query the query.
 * @param result the result set with transactions.
 *
 * @return true on success, false on failure with exception set.
 */
api.getTransactions = function(actor, query, callback) {
  // FIXME: implement me
};

/**
 * Creates a Budget ID from the given Identity ID and budget slug.
 *
 * @param ownerId the Identity ID.
 * @param name the short budget name (slug).
 *
 * @return the Budget ID.
 */
api.createBudgetId = function(ownerId, name) {
  return util.format('%s/budgets/%s', ownerId, encodeURIComponent(name));
};

/**
 * Creates a new BudgetId based on the owner's IdentityId.
 *
 * @param ownerId the ID of the Identity budget owner.
 * @param budgetId the BudgetId generated for the Budget.
 *
 * @return true on success, false on failure with exception set.
 */
virtual bool generateBudgetId(
   payswarm::common::IdentityId ownerId,
   payswarm::common::BudgetId& budgetId) = 0;

/**
 * Creates a new Budget. The "@id", "@type", "ps:owner", and
 * "com:amount" properties must be set.
 *
 * @param actor the profile performing the action.
 * @param budget the new Budget to create.
 *
 * @return true on success, false on failure with exception set.
 */
virtual bool createBudget(
   payswarm::common::Profile& actor,
   payswarm::common::Budget& budget) = 0;

/**
 * Updates an existing Budget. Use this method to change the Budget
 * parameters, do not use it to change the Budget's remaining balance or
 * its applicable vendors. Other than @id only updated fields need to
 * be included.
 *
 * @param actor the profile performing the action.
 * @param budgetUpdate the budget @id and fields to update.
 *
 * @return true on success, false on failure with exception set.
 */
virtual bool updateBudget(
   payswarm::common::Profile& actor,
   payswarm::common::Budget& budgetUpdate) = 0;

/**
 * Deletes a Budget based on its ID.
 *
 * @param actor the profile performing the action.
 * @param budgetId the ID of the budget to delete.
 *
 * @return true on success, false on failure with exception set.
 */
virtual bool removeBudget(
   payswarm::common::Profile& actor,
   payswarm::common::BudgetId budgetId) = 0;

/**
 * Updates the remaining balance on the given Budget.
 *
 * @param actor the profile performing the action.
 * @param budget the budget to update.
 * @param amount the amount to change the Budget balance by (+/-).
 *
 * @return true on success, false on failure with exception set.
 */
virtual bool updateBudgetBalance(
   payswarm::common::Profile& actor,
   payswarm::common::Budget& budget,
   payswarm::common::Money& amount) = 0;

/**
 * Adds a vendor to a Budget.
 *
 * @param actor the profile performing the action.
 * @param budgetId the ID of the budget.
 * @param vendorId the ID of the vendor to add.
 *
 * @return true on success, false on failure with exception set.
 */
virtual bool addBudgetVendor(
   payswarm::common::Profile& actor,
   payswarm::common::BudgetId budgetId,
   payswarm::common::IdentityId vendorId) = 0;

/**
 * Removes a vendor from a Budget.
 *
 * @param actor the profile performing the action.
 * @param budgetId the ID of the budget.
 * @param vendorId the ID of the vendor to remove.
 *
 * @return true on success, false on failure with exception set.
 */
virtual bool removeBudgetVendor(
   payswarm::common::Profile& actor,
   payswarm::common::BudgetId budgetId,
   payswarm::common::IdentityId vendorId) = 0;

/**
 * Populates Budgets based on the given query. The query may contain
 * "budget" or "identity" (and "vendor" optionally along with "identity"),
 * where these fields refer to the ID of a specific budget, the ID of an
 * identity, and the ID of a vendor, respectively.
 *
 * @param actor the profile performing the action.
 * @param query the query to use.
 * @param result the result set with Budgets.
 * @param meta to store the meta data for the Budgets.
 *
 * @return true on success, false on failure with exception set.
 */
virtual bool populateBudgets(
   payswarm::common::Profile& actor,
   payswarm::common::DatabaseQuery& query,
   payswarm::common::ResourceSet& result,
   monarch::rt::DynamicObject* meta = NULL) = 0;



/**
 * Creates a payment token for the given source of funds (eg: CreditCard or
 * BankAccount), if supported by the given gateway. If tokenization is not
 * supported by the gateway, the returned PaymenToken will be null.
 *
 * @param actor the Profile performing the action.
 * @param source the source of funds (eg: CreditCard, BankAccount).
 * @param gateway the gateway to create the token with.
 * @param token the PaymentToken with custom information to store.
 * @param callback(err, token) called once the operation completes.
 */
api.createPaymentToken = function(actor, source, gateway, token, callback) {
  // FIXME: implement me
};

/**
 * Gets the PaymentToken by token ID.
 *
 * @param actor the Profile performing the action.
 * @param token the PaymentToken to populate, with its token and owner set.
 *
 * @return true on success, false on failure with exception set.
 */
virtual bool getPaymentToken(
   payswarm::common::Profile& actor,
   payswarm::common::PaymentToken& token) = 0;

/**
 * Gets all the PaymentTokens for the given identity.
 *
 * The query must contain "ps:owner" and may optionally contain:
 *
 * "com:gateway": The gateway for the tokens.
 *
 * @param actor the Profile performing the action.
 * @param query the query for getting payment tokens.
 * @param tokens the list to populate with payment tokens.
 *
 * @return true on success, false on failure with exception set.
 */
virtual bool getPaymentTokens(
   payswarm::common::Profile& actor,
   monarch::rt::DynamicObject& query,
   monarch::rt::DynamicObject& tokens) = 0;

/**
 * Adds a new PaymentToken. The PaymentToken's ID will be generated based
 * on its label.
 *
 * @param actor the Profile performing the action.
 * @param token the PaymentToken to add.
 * @param changeIdOnDuplicate true to generate a new ID if the PaymentToken
 *           is a duplicate.
 *
 * @return true on success, false on failure with exception set.
 */
virtual bool addPaymentToken(
   payswarm::common::Profile& actor,
   payswarm::common::PaymentToken& token,
   bool changeIdOnDuplicate = true) = 0;

/**
 * Updates an existing PaymentToken.
 *
 * @param actor the Profile performing the action.
 * @param token the PaymentToken to update.
 *
 * @return true on success, false on failure with exception set.
 */
virtual bool updatePaymentToken(
   payswarm::common::Profile& actor,
   payswarm::common::PaymentToken& token) = 0;











/**
 * Creates a new Financial Account, inserting it into the database.
 *
 * @param account the Account to create.
 * @param callback(err) called once the operation completes.
 */
function _createAccount(account, callback) {
  var defaults = payswarm.config.account.defaults;

  // force balances for new accounts to zero
  account['com:balance'] = '0.0000000';
  account['com:escrow'] = '0.0000000';

  // add account defaults
  account = payswarm.tools.extend(
    true, {}, defaults.account, account);

  // insert the account
  var now = +new Date();
  var record = {
    id: payswarm.db.hash(account['@id']),
    owner: payswarm.db.hash(account['ps:owner']),
    meta: {
      created: now,
      updated: now
    },
    account: account
  };
  payswarm.db.collections.account.insert(
    record, payswarm.db.writeOptions, callback);
}

/**
 * Checks if an actor owns an Account.
 *
 * @param actor the actor to compare against.
 * @param account the Account to compare.
 * @param callback(err, owns) called once the operation completes.
 */
function _checkAccountOwner(actor, account, callback) {
  async.waterfall([
    function(callback) {
      if('ps:owner' in account) {
        callback(null, account);
      }
      else {
        api.getAccount(actor, account['@id'], function(err, account) {
          callback(err, account);
        });
      }
    },
    function(account, callback) {
      payswarm.identity.checkIdentityObjectOwner(actor, account, callback);
    }
  ], callback);
}

/**
 * Checks if an actor owns a Budget.
 *
 * @param actor the actor to compare against.
 * @param budget the Budget to compare.
 * @param callback(err, owns) called once the operation completes.
 */
function _checkBudgetOwner(actor, budget, callback) {
  async.waterfall([
    function(callback) {
      if('ps:owner' in budget) {
        callback(null, budget);
      }
      else {
        api.getBudget(actor, budget['@id'], function(err, budget) {
          callback(err, budget);
        });
      }
    },
    function(budget, callback) {
      payswarm.identity.checkIdentityObjectOwner(actor, budget, callback);
    }
  ], callback);
}

/**
 * Checks if an actor owns a PaymentToken.
 *
 * @param actor the actor to compare against.
 * @param paymentToken the PaymentToken to compare.
 * @param callback(err, owns) called once the operation completes.
 */
function _checkPaymentTokenOwner(actor, paymentToken, callback) {
  async.waterfall([
    function(callback) {
      if('ps:owner' in paymentToken) {
        callback(null, paymentToken);
      }
      else {
        api.getPaymentToken(actor, paymentToken['@id'],
          function(err, paymentToken) {
            callback(err, paymentToken);
        });
      }
    },
    function(paymentToken, callback) {
      payswarm.identity.checkIdentityObjectOwner(actor, paymentToken, callback);
    }
  ], callback);
}

/**
 * Registers the permissions for this module.
 *
 * @param callback(err) called once the operation completes.
 */
function _registerPermissions(callback) {
  var permissions = [{
    '@id': PERMISSIONS.ACCOUNT_ADMIN,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Account Administration',
    'rdfs:comment': 'Required to administer Accounts.'
  }, {
    '@id': PERMISSIONS.ACCOUNT_ACCESS,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Access Account',
    'rdfs:comment': 'Required to access an Account.'
  }, {
    '@id': PERMISSIONS.ACCOUNT_CREATE,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Create Account',
    'rdfs:comment': 'Required to create an Account.'
  }, {
    '@id': PERMISSIONS.ACCOUNT_EDIT,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Edit Account',
    'rdfs:comment': 'Required to edit an Account.'
  }, {
    '@id': PERMISSIONS.ACCOUNT_REMOVE,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Remove Account',
    'rdfs:comment': 'Required to remove an Account.'
  }, {
    '@id': PERMISSIONS.BUDGET_ADMIN,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Budget Administration',
    'rdfs:comment': 'Required to administer Budgets.'
  }, {
    '@id': PERMISSIONS.BUDGET_ACCESS,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Access Budget',
    'rdfs:comment': 'Required to access a Budget.'
  }, {
    '@id': PERMISSIONS.BUDGET_CREATE,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Create Budget',
    'rdfs:comment': 'Required to create a Budget.'
  }, {
    '@id': PERMISSIONS.BUDGET_EDIT,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Edit Budget',
    'rdfs:comment': 'Required to edit a Budget.'
  }, {
    '@id': PERMISSIONS.BUDGET_REMOVE,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Remove Budget',
    'rdfs:comment': 'Required to remove a Budget.'
  }, {
    '@id': PERMISSIONS.PTOKEN_ADMIN,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Payment Token Administration',
    'rdfs:comment': 'Required to administer Payment Tokens.'
  }, {
    '@id': PERMISSIONS.PTOKEN_ACCESS,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Access Payment Token',
    'rdfs:comment': 'Required to access a Payment Token.'
  }, {
    '@id': PERMISSIONS.PTOKEN_CREATE,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Create Payment Token',
    'rdfs:comment': 'Required to create a Payment Token.'
  }, {
    '@id': PERMISSIONS.PTOKEN_EDIT,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Edit Payment Token',
    'rdfs:comment': 'Required to edit a Payment Token.'
  }, {
    '@id': PERMISSIONS.PTOKEN_REMOVE,
    'psa:module': MODULE_IRI,
    'rdfs:label': 'Remove Payment Token',
    'rdfs:comment': 'Required to remove a Payment Token.'
  }];
  async.forEach(permissions, function(p, callback) {
    payswarm.permission.registerPermission(p, callback);
  }, callback);
}
